/* -----------------------------------------------------------------------------
 * This file was automatically generated by a Python script.
 * PLEASE DON'T EDIT IT DIRECTLY, your changes would be overwritten the next time the script is run.
 * Instead, go to "Particle Nodes Generator/1 Force/Collision.clbtemp"
 * and see https://coollab-art.com/Tutorials/Writing%20Nodes/Particle%20nodes.
 * -----------------------------------------------------------------------------
 */

vec3 gradient91529481(vec3 p)
{
    float h = 0.001;
    return vec3(
        'Shape'(p - vec3(h, 0, 0)) - 'Shape'(p + vec3(h, 0, 0)),
        'Shape'(p - vec3(0, h, 0)) - 'Shape'(p + vec3(0, h, 0)),
        'Shape'(p - vec3(0, 0, h)) - 'Shape'(p + vec3(0, 0, h))
    ) / (2. * h);
}

// To learn how to write nodes, see https://coollab-art.com/Tutorials/Writing%20Nodes/Intro

INPUT vec3->SignedDistance 'Shape';
INPUT int 'Quality';
INPUT int 'Fix narrow shapes';
INPUT float 'Fix Shape Artifacts';

struct IntersectionResult {
    bool  has_intersected;
    vec3 intersection_point;
    float distance_along_ray;
};

vec3 set_length(vec3 vector, float new_length)
{
    float len = length(vector);
    if (len < 0.000001)
        return vec3(new_length, 0., 0);
    return vector / len * new_length;
}

IntersectionResult intersect_with_shape(Particle3D particle, bool particle_is_outside, float surface_distance)
{
    float t = 0.;

    const vec3 ZERO     = vec3(0.); // HACK to work around a bug in particle_nodes_generator.py that prevents us to use a macro as a parameter of another macro
    vec3 velocity = (particle.velocity + particle.acceleration * _delta_time) * _delta_time;
    for (int i = 0; i < 'Quality'; i++)
    {
        vec3 point = particle.position + set_length(velocity, 1.) * t;
        float d     = abs('Shape'(point) - (particle_is_outside ? particle.size : 0.));
        t += d * (1. - 'Fix Shape Artifacts');

        if (particle_is_outside && t > length(velocity))
            return IntersectionResult(false, ZERO, 0.);

        if (d < surface_distance && t > 0)
            return IntersectionResult(true, point, t);
    }
    return IntersectionResult(false, ZERO, 0.);
}

Particle3D main(Particle3D Particle)
{
    // TODO(Particles) There are leaks in collisions. Ideally this effect would be applied after the velocity has been updated and before the position has been updated.

    const float SURF_DIST = 0.001;

    float distance = 'Shape'(Particle.position) - Particle.size;

    if (distance < 0.)
    {
        IntersectionResult intersection = intersect_with_shape(Particle, false, SURF_DIST);
        Particle.position += set_length(Particle.velocity, intersection.distance_along_ray + Particle.size);
    }
    else
    {
        IntersectionResult intersection = intersect_with_shape(Particle, true, SURF_DIST);
        for (int i = 0; i < 'Fix narrow shapes'; ++i)
        {
            if (!intersection.has_intersected)
                break;

            vec3 shape_normal = normalize(gradient91529481(intersection.intersection_point));
            Particle.position = intersection.intersection_point - shape_normal * SURF_DIST * 1.1; // We must offset from the surface by an amout > SURF_DIST otherwise we would detect a collision immediately.
            Particle.velocity = reflect(Particle.velocity, shape_normal);

            intersection = intersect_with_shape(Particle, true, SURF_DIST);
        }
    }
    return Particle;
}
